/* PickADate pattern.
 *
 * Options:
 *    date(object): Date widget options described here. If false is selected date picker wont be shown. ({{selectYears: true, selectMonths: true })
 *    time(object): Time widget options described here. If false is selected time picker wont be shown. ({})
 *    separator(string): Separator between date and time if both are enabled.
 *    (' ')
 *    classClearName(string): Class name of element that is generated by pattern. ('pattern-pickadate-clear')
 *    classDateName(string): Class applied to date input. ('pattern-pickadate-date')
 *    classDateWrapperName(string): Class applied to extra wrapper div around date input. ('pattern-pickadate-date-wrapper')
 *    classSeparatorName(string): Class applied to separator. ('pattern-pickadate-separator')
 *    classTimeName(string): Class applied to time input. ('pattern-pickadate-time')
 *    classTimeWrapperName(string): Class applied to wrapper div around time input. ('pattern-pickadate-time-wrapper')
 *    classTimezoneName(string): Class applied to timezone input. ('pattern-pickadate-timezone')
 *    classTimezoneWrapperName(string): Class applied to wrapper div around timezone input. ('pattern-pickadate-timezone-wrapper')
 *    classWrapperName(string): Class name of element that is generated by pattern. ('pattern-pickadate-wrapper')
 *
 * Documentation:
 *    # Date and Time
 *
 *    {{ example-1 }}
 *
 *    # Date and Time with initial data
 *
 *    {{ example-2 }}
 *
 *    # Date
 *
 *    {{ example-3 }}
 *
 *    # Date with initial date
 *
 *    {{ example-4 }}
 *
 *    # Time
 *
 *    {{ example-5 }}
 *
 *    # Time with initial time
 *
 *    {{ example-6 }}
 *
 *    # Date and time with timezone
 *
 *    {{ example-7 }}
 *
 *    # Date and time with timezone and default value
 *
 *    {{ example-8 }}
 *
 *    # Date and time with one timezone
 *
 *    {{ example-9 }}
 *
 * Example: example-1
 *    <input class="pat-pickadate"/>
 *
 * Example: example-2
 *    <input class="pat-pickadate" value="2010-12-31 00:45" />
 *
 * Example: example-3
 *    <input class="pat-pickadate" data-pat-pickadate="time:false"/>
 *
 * Example: example-4
 *    <input class="pat-pickadate" value="2010-12-31" data-pat-pickadate="time:false"/>
 *
 * Example: example-5
 *    <input class="pat-pickadate" data-pat-pickadate="date:false"/>
 *
 * Example: example-6
 *    <input class="pat-pickadate" value="00:00" data-pat-pickadate="date:false"/>
 *
 * Example: example-7
 *    <input class="pat-pickadate" data-pat-pickadate='{"timezone": {"data": [{"id":"Europe/Berlin","text":"Europe/Berlin"},{"id":"Europe/Vienna","text":"Europe/Vienna"}]}}'/>
 *
 * Example: example-8
 *    <input class="pat-pickadate" data-pat-pickadate='{"timezone": {"default": "Europe/Vienna", "data": [{"id":"Europe/Berlin","text":"Europe/Berlin"},{"id":"Europe/Vienna","text":"Europe/Vienna"}]}}'/>
 *
 * Example: example-9
 *    <input class="pat-pickadate" data-pat-pickadate='{"timezone": {"data": [{"id":"Europe/Berlin","text":"Europe/Berlin"}]}}'/>
 *
 */

(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define([
            'jquery',
            "pat-registry",
            "pat-parser",
            'picker',
            'picker.date',
            'picker.time',
            'pat-autosuggest',
            'i18n'
        ], function() {
            return factory.apply(this, arguments);
        });
    } else {
        factory($, root.patterns, root.patterns.Parser, Picker, PickerDate, PickerTime, Autosuggest, _t);
    }
}(this, function($, registry, Parser, Picker, PickerDate, PickerTime, patternSelect2, _t) {
  'use strict';
  var parser = new Parser("pickadate");
  parser.add_argument("date", true); //  If false is selected date picker wont be shown.
  parser.add_argument("time", true); // If false is selected time picker wont be shown.
  parser.add_argument("timezone");
  parser.add_argument("separator", ' '); // Separator between date and time if both are enabled.

  // XXX Camel case names are for Mockup compat
  // Class name of element that is generated by pattern. ('pattern-pickadate-clear')
  parser.add_argument("class-clear-name", 'pattern-pickadate-clear');
  parser.add_argument("classClearName", 'pattern-pickadate-clear');
  // Class applied to date input. ('pattern-pickadate-date')
  parser.add_argument("class-date-name", 'pattern-pickadate-date');
  parser.add_argument("classDateName", 'pattern-pickadate-date');
  // Class applied to extra wrapper div around date input. ('pattern-pickadate-date-wrapper')
  parser.add_argument("class-date-wrapper-name", 'pattern-pickadate-date-wrapper');
  parser.add_argument("classDateWrapperName", 'pattern-pickadate-date-wrapper');
  // Class applied to separator. ('pattern-pickadate-separator')
  parser.add_argument("class-separator-name", 'pattern-pickadate-separator');
  parser.add_argument("classSeparatorName", 'pattern-pickadate-separator');
  // Class applied to time input. ('pattern-pickadate-time')
  parser.add_argument("class-time-name", 'pattern-pickadate-time');
  parser.add_argument("classTimeName", 'pattern-pickadate-time');
  // Class applied to wrapper div around time input. ('pattern-pickadate-time-wrapper')
  parser.add_argument("class-time-wrapper-name", 'pattern-pickadate-time-wrapper');
  parser.add_argument("classTimeWrapperName", 'pattern-pickadate-time-wrapper');
  // Class applied to timezone input. ('pattern-pickadate-timezone')
  parser.add_argument("class-timezone-name", 'pattern-pickadate-timezone');
  parser.add_argument("classTimezoneName", 'pattern-pickadate-timezone');
  // class applied to wrapper div around timezone input. ('pattern-pickadate-timezone-wrapper')
  parser.add_argument("class-timezone-wrapper-name", 'pattern-pickadate-timezone-wrapper');
  parser.add_argument("classTimezoneWrapperName", 'pattern-pickadate-timezone-wrapper');
  // Class name of element that is generated by pattern. ('pattern-pickadate-wrapper')
  parser.add_argument("classWrapperName", 'pattern-pickadate-wrapper');
  parser.add_argument("class-wrapper-name", 'pattern-pickadate-wrapper');

  var pickadate = {
    name: 'pickadate',
    trigger: ".pat-pickadate",
    options: {
      date: { selectYears: true, selectMonths: true },
      placeholderDate: _t('Enter date...'),
      placeholderTime: _t('Enter time...'),
      placeholderTimezone: _t('Enter timezone...'),
      time: {},
      timezone: null
    },

    init: function patPickadateInit ($el, opts) {
      var self = this,
          value = $el.val().split(' '),
          dateValue = value[0] || '',
          timeValue = value[1] || '';

      this.options = $.extend(this.options, parser.parse($el, opts));
      this.options.date = this.isFalse(this.options.date);
      this.options.time = this.isFalse(this.options.time);
      if (self.options.date === false) {
        timeValue = value[0];
      }
      $el.hide();

      this.$wrapper = $('<div/>')
            .addClass(self.options.classWrapperName)
            .insertAfter($el);

      if (self.options.date !== false) {
        self.options.date.formatSubmit = 'yyyy-mm-dd';
        self.$date = $('<input type="text"/>')
              .attr('placeholder', self.options.placeholderDate)
              .attr('data-value', dateValue)
              .addClass(self.options.classDateName)
              .appendTo($('<div/>')
                  .addClass(self.options.classDateWrapperName)
                  .appendTo(self.$wrapper))
              .pickadate($.extend(true, {}, self.options.date, {
                onSet: function(e) {
                  if (e.select !== undefined) {
                    self.$date.attr('data-value', e.select);
                    if (self.options.time === false ||
                        self.$time.attr('data-value') !== '') {
                      self.updateValue.call(self, $el);
                    }
                  }
                  if (e.hasOwnProperty('clear')) {
                    $el.removeAttr('value');
                    self.$date.attr('data-value', '');
                  }
                }
              }));
      }

      if (self.options.date !== false && self.options.time !== false) {
        self.$separator = $('<span/>')
              .addClass(self.options.classSeparatorName)
              .html(self.options.separator === ' ' ? '&nbsp;'
                                                   : self.options.separator)
              .appendTo(self.$wrapper);
      }

      if (self.options.time !== false) {
        self.options.time.formatSubmit = 'HH:i';
        self.$time = $('<input type="text"/>')
              .attr('placeholder', self.options.placeholderTime)
              .attr('data-value', timeValue)
              .addClass(self.options.classTimeName)
              .appendTo($('<div/>')
                  .addClass(self.options.classTimeWrapperName)
                  .appendTo(self.$wrapper))
              .pickatime($.extend(true, {}, self.options.time, {
                onSet: function(e) {
                  if (e.select !== undefined) {
                    self.$time.attr('data-value', e.select);
                    if (self.options.date === false ||
                        self.$date.attr('data-value') !== '') {
                      self.updateValue.call(self, $el);
                    }
                  }
                  if (e.hasOwnProperty('clear')) {
                    $el.removeAttr('value');
                    self.$time.attr('data-value', '');
                  }
                }
              }));

        // XXX: bug in pickatime
        // work around pickadate bug loading 00:xx as value
        if (typeof(timeValue) === 'string' && timeValue.substring(0,2) === '00') {
          self.$time.pickatime('picker').set('select', timeValue.split(':'));
          self.$time.attr('data-value', timeValue);
        }
      }

      if (self.options.date !== false && self.options.time !== false && self.options.timezone) {
        self.$separator = $('<span/>')
              .addClass(self.options.classSeparatorName)
              .html(self.options.separator === ' ' ? '&nbsp;'
                                                   : self.options.separator)
              .appendTo(self.$wrapper);
      }

      if (self.options.timezone !== null) {
        self.$timezone = $('<input type="text" class="pat-autosuggest" />')
          .addClass(self.options.classTimezoneName)
          .attr('placeholder', self.options.placeholderTimezone)
          .attr('data-pat-autosuggest',
              'words-json: '+ (JSON.stringify(self.options.timezone.data) || "") +
              '; pre-fill: '+ (self.options.timezone.default || "") +
              '; maximum-selection-size: 1')
          .appendTo($('<div/>')
            .addClass(self.options.classTimezoneWrapperName)
            .appendTo(self.$wrapper))
          .on('change', function(e) {
            if (e.val !== undefined){
              self.$timezone.attr('data-value', e.val);
              if ((self.options.date === false || self.$date.attr('data-value') !== '') &&
                  (self.options.time === false || self.$time.attr('data-value') !== '')) {
                self.updateValue.call(self, $el);
              }
            }
          });
        registry.scan(this.$timezone.parent(), ['autosuggest']);

        var defaultTimezone = self.options.timezone.default;
        // if timezone has a default value included
        if (defaultTimezone) {
          var isInList;
          // the timezone list contains the default value
          self.options.timezone.data.forEach(function(obj) {
            isInList = (obj.text === self.options.timezone.default) ? true : false;
          });
          if (isInList) {
            self.$timezone.attr('data-value', defaultTimezone);
            self.$timezone.parent().find('.select2-chosen').text(defaultTimezone);
          }
        }
        // if data contains only one timezone this value will be chosen
        // and the timezone dropdown list will be disabled and
        if (self.options.timezone.data.length === 1) {
          self.$timezone.attr('data-value', self.options.timezone.data[0].text);
          self.$timezone.parent().find('.select2-chosen').text(self.options.timezone.data[0].text);
          self.$timezone.select2('enable', false);
        }
      }

      self.$clear = $('<div/>')
        .addClass(self.options.classClearName)
        .appendTo(self.$wrapper);

    },

    isFalse: function(value) {
      if (typeof(value) === 'string' && value === 'false') {
        return false;
      }
      return value;
    },

    updateValue: function($el) {
      var self = this,
          value = '';

      if (self.options.date !== false) {
        var date = self.$date.data('pickadate').component,
            dateValue = self.$date.data('pickadate').get('select'),
            formatDate = date.formats.toString;
        if (dateValue) {
          value += formatDate.apply(date, ['yyyy-mm-dd', dateValue]);
        }
      }

      if (self.options.date !== false && self.options.time !== false) {
        value += ' ';
      }

      if (self.options.time !== false) {
        var time = self.$time.data('pickatime').component,
            timeValue = self.$time.data('pickatime').get('select'),
            formatTime = time.formats.toString;
        if (timeValue) {
          value += formatTime.apply(time, ['HH:i', timeValue]);
        }
      }

      if (self.options.timezone !== null) {
        var timezone = ' ' + self.$timezone.attr('data-value');
        if (timezone) {
          value += timezone;
        }
      }
      $el.attr('value', value);
      $el.trigger('updated');
    }
  };
  registry.register(pickadate);
}));
